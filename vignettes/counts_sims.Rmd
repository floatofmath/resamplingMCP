---
title: "Untitled"
author: "livio Finos"
date: "12/10/2015"
output: html_document
---

```{r}
library(resamplingMCP)
library(magrittr)
library(plyr)
library(dplyr)
library(pander)
library(parallel)
library(bt88.03.704)
library(flip)
library(MASS)
options(mc.cores=detectCores()-1)

#source('~/github/resamplingMCP/R/simulation.R', echo=TRUE)

summaryResSim <- function(res,alphas=c(.01,.05,.1,.5,.75),na.rm=FALSE){
  out=sapply(alphas,function(a)colMeans(res<=a,na.rm=na.rm))
  colnames(out)=paste("<=",alphas,sep="")
out  
}
```


# Generating paired counts
`r_counts_pair` generates paired counts as descried in the description.

The type I error is out of control (realy???)

```{r pairedCountsGeneration, echo=FALSE} 
#' @description generates differents of (paired) counts from a poisson with mean rchisq(df=df)+delta and rchisq(df=df)
r_counts_pair <- function(n,delta=0,df=2){
  means=1/rchisq(n=n,df = df)
  means[means==0]=.5
  means[means>=1000]=1000
  y=rpois(n = n,lambda = means+delta)-
    rpois(n = n,lambda = means)
  y
}

n=10
Y=matrix(r_counts_pair (n*1000,df=1),n,1000)
ps=apply(Y,2,function(y)t.test(y)$p.value)
plot.ecdf(ps);abline(0,1)
ps.prm=p.value(flip(Y))
plot.ecdf(ps.prm,add=TRUE,col="red")
pander(summaryResSim(cbind(param.t=ps,perm=ps.prm)))
```


# Generating 2 independent samples
`r_counts` generates paired counts as in the description

```{r, echo=FALSE} 
#' @description generates counts 
#' from a poisson with mean rchisq(df=df)+delta

r_counts <- function(n,delta=0,df=2){
  # if(!is.finite(disp))
  #   rpois(n,lambda=exp(mu)) else
  #   rnbinom(n,mu=exp(mu),size=exp(disp))
  means=rchisq(n=n,df = df)
  means[means==0]=.5
  means[means>=1000]=1000
  y=rpois(n = n,lambda = means+delta)
  y
}

n=20
delta=0
x=rep(0:1,each=n/2)
Y=matrix(r_counts (n*1000,df=5,delta = x*delta),n,1000)
Y=rbind(matrix(r_counts(1000*n/2,df=5),n/2),matrix(r_counts(1000*n/2,df=5,delta=delta),n/2))

ps=apply(Y,2,function(y)summary(glm(y~x,family = poisson))$coefficients[2,"Pr(>|z|)"])


ps.prm=p.value(flip(Y~x))

ps.nb=apply(Y,2,function(y)summary(glm.nb(y~x))$coefficients[2,"Pr(>|z|)"])

  
plot.ecdf(ps);abline(0,1)
plot.ecdf(ps.prm,add=TRUE,col="red");abline(0,1)
plot.ecdf(ps.nb,add=TRUE,col="green");abline(0,1)

pander(summaryResSim(cbind(param.t=ps,param.nb=ps.nb,perm=ps.prm)))
```


## Some quick simulation studies

```{r helper functions,echo=F}
adaptive_permtest_2s <- function(x,y,n1,n,ne,test_statistic,
                                 m1=n1,m=n,me=ne,perms=1000,alpha=0.025){
    if(ne>n){
        xs <- split(x,rep(1:3,c(n1,n-n1,ne-n)))
    } else {
        if(me>m) stop('Stages with controls only not supported')
        xs <- split(x,rep(1:2,c(n1,ne-n1)))
    }
    if(me>m){
        ys <- split(y,rep(1:3,c(m1,m-m1,me-m)))
    } else {
        if(ne>n) stop('Stages with treatments only not supported')
        ys <- split(y,rep(1:2,c(m1,me-m1)))
    }
    gs <- lapply(1:length(xs),function(i) rep(0:1,c(length(xs[[i]]),length(ys[[i]]))))
    xs <- lapply(1:length(xs),function(i) c(xs[[i]],ys[[i]]))
    if(me==m){
       return(alpha>=perm_test(xs[[1]],xs[[2]],gs[[1]],gs[[2]],test_statistic,B=perms))
    }
    A <- permutation_CER(xs[[1]],gs[[1]],xs[[2]],test_statistic,permutations=perms,alpha=alpha)
    q <- perm_test(xs[[2]],xs[[3]],gs[[2]],gs[[3]],test_statistic,B=perms)
    A>=q
}

##' @param rule adaptive sample size rule
##' @param rdist random number generator for the data
##' @param test_statistic function that computes the test statistic
##' @param control_opts list of options past to \code{rdist} for the control group
##' @param treatment_opts list of options past to \code{rdist} for the treatment group
##' @param m1 first stage sample size (control group)
##' @param m preplanned total sample size (control group)
##' @param ... 
##' @return list of test results 
##' @author Florian Klinglmueller
compare_adaptive_tests_2s <- function(n1,n,rule,rdist,
                                      test_statistic,
                                      control_opts=list(),
                                      treatment_opts=control_opts,
                                      m1=n1,m=n,...){
    x <- do.call(match.fun(rdist),c(n=n,control_opts))
    y <- do.call(match.fun(rdist),c(n=n,treatment_opts))
    nes <- rule(x[1:n1],y[1:m1])
    if(nes[1]>n){
        ne <- nes[1]
        x <- c(x,rdist(ne[1]-n,...))
    } else {
        ne <- n
    }
    if(nes[2]>m){
        me <- nes[2]
        y <- c(x,rdist(ne[2]-m,...))
    } else {
        me <- m
    }
    list(permtest = adaptive_permtest_2s(x,y,n1,n,ne,test_statistic,m1,m,me),
         invnorm = adaptive_invnormtest_2s(x,y,n1,n,ne,m1,m,me),
         invnorm_nb=adaptive_invnormtest_negbin_2s(x,y,n1,n,ne,m1,m,me),
         wald = adaptive_waldtest_2s(x,y,n1,n,ne))
}


##################
#' To be checked
adaptive_invnormtest_2s <- function(x,y,n1,n,ne,m1=n1,m=n,me=ne,alpha=0.025){
    xs <- split(x,rep(1:2,c(n1,ne-n1)))
    ys <- split(y,rep(1:2,c(m1,ne-m1)))
    p1 <- t.test(xs[[1]],ys[[1]],alternative='greater')$p.value
    p2 <- t.test(xs[[2]],ys[[2]],alternative='greater')$p.value
    alpha >= {sqrt(c(n1,n-n1)/n) * qnorm(c(p1,p2),lower=F)} %>% sum() %>% pnorm(lower=FALSE) 
}

#' To be checked
adaptive_invnormtest_negbin_2s <- function(x,y,n1,n,ne,m1=n1,m=n,me=ne,alpha=0.025){
   xs <- split(x,rep(1:2,c(n1,ne-n1)))
   ys <- split(y,rep(1:2,c(m1,ne-m1)))
   sg1 <- summary(glm.nb(c(xs[[1]],ys[[1]])~rep(1:2,c(n1,m1))))
   sg2 <- summary(glm.nb(c(xs[[2]],ys[[2]])~rep(1:2,c(ne-n1,ne-m1))))
   p1 <- sg1$coefficients[2,"Pr(>|z|)"]
   s1 <- sg1$coefficients[2,"z value"]>0
   p2 <- sg2$coefficients[2,"Pr(>|z|)"]
   s2 <- sg2$coefficients[2,"z value"]>0
   p1 <- ifelse(s1,p1/2,1-p1/2)
   p2 <- ifelse(s2,p2/2,1-p2/2)
   alpha >= {sqrt(c(n1,n-n1)/n) * qnorm(c(p1,p2),lower=F)} %>% sum() %>% pnorm(lower=FALSE) 
}

adaptive_waldtest_2s <- function(x,y,n1,n,ne,m1=n1,m=n,me=ne,alpha=0.025){
    log(mean(y)/mean(x))/sqrt(1/sum(x)+1/sum(y))>qnorm(alpha,lower=F)
}
###########

run_simulation <- function(n1,n,delta=0,B=10,...){
    results <- mclapply2(1:B,function(i) 
      compare_adaptive_tests_2s(n1,n,function(x,y) c(4,4),r_counts,diffmean,treatment_opts=list(delta=delta))
      )
    ##:ess-bp-start::conditional@length(unique(sapply(results,length))) != 1:##
browser(expr={length(unique(sapply(results,length))) != 1})##:ess-bp-end:##
    results %>% bind_rows %>% colMeans
}



samplesize_counts <- function(theta,lambda,k=1,t=1,alpha=0.025,beta=0.1){
    ## see friede and schmiedli 2010 (StatMed)
    nc <- (1+k*theta)^2 * (qnorm(alpha,lower=F)+qnorm(beta,lower=F))^2 / (t*lambda*(k+1)*theta*log(theta)^2)
    return(ceiling(c(nc=nc,nt=k*nc)))
}

condpowerrule_counts <- function(x,y,theta=1.5,maxN=Inf){
    k <- length(y)/length(x)
    lambda  <- mean(y) + mean(x)
    samplesize_counts(theta,lambda,k)
}

```

## missing: rules for 2 samples

## Examples

### Apply test procedures

```{r examples}
n1 <- 6
n <- 12
ne <- 15
x <- r_counts(ne,df=5)
y <- r_counts(ne,df=5,delta=4)
adaptive_permtest_2s(x,y,n1,n,ne,meandiff)
#adaptive_permtest2_os(x,n1,n,ne,possum,resam=1000)
adaptive_invnormtest_2s(x,y,n1,n,ne)
adaptive_invnormtest_negbin_2s(x,y,n1,n,ne)
adaptive_waldtest_2s(x,y,n1,n,ne)

samplesize_counts(2,5)
samplesize_counts(1.5,5)


```

### Compare tests



Not working yet: (debuging of  `adaptive_permtest_2s` is needed)
```{r try comparison}
## one example fixed rule
compare_adaptive_tests_2s(14,28,condpowerrule_counts,control_opts=list(df=5),treatment_opts=list(df=5,delta=2.5),rdist=r_counts,df=5,delta=2.5,test_statistic=meandiff)

```

```{r simulation example,eval=F}
run_scenario_counts <- function(B,...){
    ## just a wrapper around mclapply2
    browser()
    scenario <- list(...)
    results <- mclapply2(1:B,function(i) compare_adaptive_tests_2s(n1=scenario$n1,
                                                                   n=scenario$n,
                                                                   rule=scenario$rule,rdist=scenario$rdist,
                                                                   test_statistic=scenario$test_statistic,
                                                                   control_opts=list(df=scenario$df),
                                                                   treatment_opts=list(df=scenario$df,delta=scenario$df*(scenario$theta-1))))
    results %>% bind_rows %>% summarize(ASN=mean(ne),maxSN=max(ne),permtest=mean(permtest),invnormT=mean(invnorm),invnormNB=mean(invnorm_nb),wald=mean(wald))#,npcomb=mean(npcomb),permtest=mean(permtest))
}

run_simulation_counts <- function(scenarios,B=100,...){
    params <- list(...)
    bind_rows(lapply(1:nrow(scenarios),function(p) c(scenarios[p,],do.call('run_scenario_counts',c(B=B,scenarios[p,],params)))))
}

scenarios_test <- expand.grid(n1=14,
                              n=28,
                              theta= c(1,1.5),
                              df = c(3,5),
                              perms= 500)
                              
run_simulation_counts(scenarios_test,rule=condpowerrule_counts,rdist=r_counts,test_statistic=meandiff)

```
